<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Em vez disso, espere o {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Em vez disso, use a espera</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Esperar de forma síncrona por tarefas ou awaiters pode causar deadlocks. Em vez disso, use await ou JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Evite esperas síncronas problemáticas</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Invoque os tipos single-threaded no thread principal</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Evite métodos "async void”, pois exceções que não são manipuladas pelo método causarão falha no processo.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Evite métodos async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Evite usar o lambda async void para um tipo de delegado que é retornado nulo, pois todas as exceções que não são manipuladas pelo delegado causarão falha no processo.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Evite delegados assíncronos sem suporte</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Os delegados do AsyncEventHandler devem ser invocados por meio do método de extensão "TplExtensions.InvokeAsync()" definido no assembly Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Use InvokeAsync para acionar eventos assíncronos</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Chamar await em uma Task em JoinableTaskFactory.Run, quando a tarefa for inicializada fora do delegado pode causar deadlocks em potencial.
Você pode evitar esse problema assegurando que a tarefa seja inicializada no delegado ou usando JoinableTask em vez de Task.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Evite aguardar tarefas não unidas em contextos de junção</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;. O valor pode apresentar deadlock.
Em vez disso, use AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Usar AsyncLazy&lt;T&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>O {0} é bloqueado de forma síncrona. Em vez disso, espere o {1}.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>O {0} é bloqueado de forma síncrona. Em vez disso, use await.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Chame métodos assíncronos quando estiver em um método assíncrono</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Limite o uso bloqueando sincronicamente chamadas de método como JoinableTaskFactory.Run ou Task.Result para membros de ponto de entrada no qual você deve ser síncrono. Usar isso para membros internos pode adicionar sem necessidade estruturas síncronas entre estruturas assíncronas, levando à exaustão de pool de threads.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Implementar a lógica interna de forma assíncrona</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Renomear para {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Use o sufixo "Async" para métodos assíncronos</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Alterar o tipo de retorno para Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Evite sobrecargas de método que assumem TaskScheduler.Current. Use uma sobrecarga que aceita um TaskScheduler e especifique TaskScheduler.Default (ou qualquer outro) explicitamente.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Evite sobrecargas de método que assumem TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Forneça uma instância de JoinableTaskFactory nessa chamada (ou outra sobrecarga) para evitar deadlocks com o thread principal.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Fornecer o JoinableTaskFactory quando permitido</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Exporte uma versão assíncrona desse método que não bloqueia de forma síncrona. Em seguida, simplifique esse método para chamar esse método assíncrono em um delegado JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Oferecer métodos assíncronos</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Espere que o JoinableTaskFactory.SwitchToMainThreadAsync() mude o thread da interface do usuário em vez das APIs que podem realizar deadlock ou requerer a especificação de uma prioridade.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Evitar APIs de troca de treads herdadas</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Operador await ausente para a expressão “using”</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Await Task em uma expressão using</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Expressão await using</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Em vez disso, use a espera</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>As verificações de afinidade de thread devem ser incondicionais.</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>Declarar a afinidade de thread de forma incondicional</value>
  </data>
  <data name="VSTHRD109_MessageFormat" xml:space="preserve">
    <value>Evite lançar quando não estiver no thread principal enquanto estiver em um método assíncrono ou de Retorno de tarefa. Mude para o thread necessário em vez disso.</value>
  </data>
  <data name="VSTHRD109_Title" xml:space="preserve">
    <value>Mude em vez de declarar em métodos assíncronos</value>
  </data>
  <data name="VSTHRD010_MessageFormat_Sync" xml:space="preserve">
    <value>O acesso a "{0}" deve ser realizado somente no thread principal. Chame {1}() primeiro.</value>
    <comment>{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat_Async" xml:space="preserve">
    <value>O acesso a "{0}" deve ser realizado somente no thread principal. Aguarde JoinableTaskFactory.SwitchToMainThreadAsync() primeiro.</value>
    <comment>{0} is a type or member name.</comment>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>Chamadas a JoinableTaskFactory.SwitchToMainThreadAsync() devem ser aguardadas.</value>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>Aguarde SwitchToMainThreadAsync</value>
    <comment>Do not translate either of these. The first is a keyword, the second is a method name.</comment>
  </data>
  <data name="VSTHRD110_MessageFormat" xml:space="preserve">
    <value>Observe o resultado esperável dessa chamada de método aguardando-o, atribuindo-o a uma variável ou passando-o a outro método.</value>
  </data>
  <data name="VSTHRD110_Title" xml:space="preserve">
    <value>Observe o resultado das chamadas assíncronas</value>
  </data>
  <data name="VSTHRD011b_MessageFormat" xml:space="preserve">
    <value>A invocação ou bloqueio em código assíncrono em um alocador de valor Lazy&lt;T&gt; pode causar um deadlock.
Use AsyncLazy&lt;T&gt; em vez disso.</value>
  </data>
  <data name="VSTHRD200_AddAsync_MessageFormat" xml:space="preserve">
    <value>Use o sufixo "Async" em nomes de métodos que retornam um tipo esperável.</value>
  </data>
  <data name="VSTHRD200_RemoveAsync_MessageFormat" xml:space="preserve">
    <value>Evite o sufixo "Async" em nomes de métodos que não retornam um tipo esperável.</value>
  </data>
  <data name="VSTHRD111_CodeFix_False_Title" xml:space="preserve">
    <value>Adicione .ConfigureAwait(false)</value>
    <comment>".ConfigureAwait(false)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_CodeFix_True_Title" xml:space="preserve">
    <value>Adicione .ConfigureAwait(true)</value>
    <comment>".ConfigureAwait(true)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_MessageFormat" xml:space="preserve">
    <value>Adicione .ConfigureAwait(bool) a sua expressão await.</value>
    <comment>".ConfigureAwait(bool)" and "await" should NOT be translated.</comment>
  </data>
  <data name="VSTHRD111_Title" xml:space="preserve">
    <value>Use ConfigureAwait(bool)</value>
    <comment>"ConfigureAwait(bool)" is a reference and should NOT be translated.</comment>
  </data>
</root>