<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>改為 await {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>改用 await</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>同步等候 task 或 awaiter 可能會造成死結。請改用 await 或 JoinableTaskFactory.Run。</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>避免有問題的同步等候</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>在主執行緒叫用單一執行緒類型</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>因為任何不是由 "async void" 方法處理的例外狀況都會使處理序損毀，所以請避免該方法。</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>避免 async void 方法</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>因為任何不是由 void 傳回委派類型處理的例外狀況都會使處理序損毀，所以請避免對該類型使用非同步 lambda。</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>避免不支援的非同步委派</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler 委派應透過在 Microsoft.VisualStudio.Threading 組件中定義的延伸模組方法 "TplExtensions.InvokeAsync()" 叫用。</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>使用 InvokeAsync 引發非同步事件</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>當工作在委派外部初始化時，在 JoinableTaskFactory.Run 內的 Task 上呼叫 await，可能會造成潛在的鎖死情形。
您可以藉由確認工作在委派內初始化，或將 Task 改為使用 JoinableTask，來避免此問題。</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>避免在加入內容中等候不可加入的工作</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value 可能會造成死結。
請改用 AsyncLazy&lt;T&gt;。</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>使用 AsyncLazy&lt;T&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} 會同步封鎖。請改用 await {1}。</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} 會同步封鎖。請改用 await。</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>在使用非同步方法時呼叫非同步方法</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>在必須同步時，請限制對公開輸入點成員使用 JoinableTaskFactory.Run 或 Task.Result 這類同步封鎖方法呼叫。對內部成員使用這種方法，可能會在非同步框架之間新增不必要的同步框架，而消耗執行緒集區。</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>以非同步方式實作內部邏輯</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>重新命名為 {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>對非同步方法使用 "Async" 尾碼</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>將傳回類型變更為 Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>請避免會假設 TaskScheduler.Current 的方法多載。請使用接受 TaskScheduler 的多載，並明確指定 TaskScheduler.Default (或其他任一項)。</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>避免假設 TaskScheduler.Current 的方法多載</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>在此呼叫 (或其他多載) 中提供 JoinableTaskFactory 執行個體，以避免主執行緒發生死結。</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>在允許的情況下提供 JoinableTaskFactory</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>提供此方法不會同步封鎖的非同步版本，讓此方法在 JoinableTaskFactory.Run 委派中只呼叫該非同步方法。</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>提供非同步方法</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Await JoinableTaskFactory.SwitchToMainThreadAsync() 可切換至 UI 執行緒，而不會切換至可能會造成死結，或必須指定優先順序的 API。</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>避免傳統執行緒切換 API</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>"using" 運算式缺少 await 運算子。</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>using 運算式中的 Await Task</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Await using 運算式</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>改用 await</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>執行緒親和性檢查應該無條件。</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>無條件判斷提示執行緒親和性</value>
  </data>
  <data name="VSTHRD109_MessageFormat" xml:space="preserve">
    <value>使用非同步或 Task-returning 方法時，若不在主執行緒，則請避免擲回。請改為切換到需要的執行緒。</value>
  </data>
  <data name="VSTHRD109_Title" xml:space="preserve">
    <value>使用非同步方法時請切換而非判斷提示</value>
  </data>
  <data name="VSTHRD010_MessageFormat_Sync" xml:space="preserve">
    <value>"{0}" 的存取只應在主執行緒完成。請先呼叫 {1}()。</value>
    <comment>{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat_Async" xml:space="preserve">
    <value>"{0}" 的存取只應在主執行緒完成。請先等候 JoinableTaskFactory.SwitchToMainThreadAsync()。</value>
    <comment>{0} is a type or member name.</comment>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>必須等候對 JoinableTaskFactory.SwitchToMainThreadAsync() 的呼叫。</value>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>等候 SwitchToMainThreadAsync</value>
    <comment>Do not translate either of these. The first is a keyword, the second is a method name.</comment>
  </data>
  <data name="VSTHRD110_MessageFormat" xml:space="preserve">
    <value>觀察此方法呼叫的可等候結果，方法是加以等候、指派至變數，或傳遞至另一個方法。</value>
  </data>
  <data name="VSTHRD110_Title" xml:space="preserve">
    <value>觀察非同步呼叫的結果</value>
  </data>
  <data name="VSTHRD011b_MessageFormat" xml:space="preserve">
    <value>在 Lazy&lt;T&gt; 值 Factory 中叫用或封鎖非同步程式碼可能會鎖死。
請改用 AsyncLazy&lt;T&gt;。</value>
  </data>
  <data name="VSTHRD200_AddAsync_MessageFormat" xml:space="preserve">
    <value>請在傳回可等候類型的方法名稱中使用 "Async" 後置詞。</value>
  </data>
  <data name="VSTHRD200_RemoveAsync_MessageFormat" xml:space="preserve">
    <value>請避免在不傳回可等候類型的方法名稱中使用 "Async" 後置詞。</value>
  </data>
  <data name="VSTHRD111_CodeFix_False_Title" xml:space="preserve">
    <value>新增 .ConfigureAwait(false)</value>
    <comment>".ConfigureAwait(false)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_CodeFix_True_Title" xml:space="preserve">
    <value>新增 .ConfigureAwait(true)</value>
    <comment>".ConfigureAwait(true)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_MessageFormat" xml:space="preserve">
    <value>將 .ConfigureAwait(bool) 新增至您的 await 運算式。</value>
    <comment>".ConfigureAwait(bool)" and "await" should NOT be translated.</comment>
  </data>
  <data name="VSTHRD111_Title" xml:space="preserve">
    <value>使用 ConfigureAwait(bool)</value>
    <comment>"ConfigureAwait(bool)" is a reference and should NOT be translated.</comment>
  </data>
</root>