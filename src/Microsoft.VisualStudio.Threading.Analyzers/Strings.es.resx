<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Use await {0} en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Use await en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>La espera sincrónica de tareas o elementos que ejecutan await puede provocar interbloqueos. Use await o JoinableTaskFactory.Run en su lugar.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Evite esperas sincrónicas problemáticas</value>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Invocar tipos uniproceso en el subproceso principal</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Evite métodos "async void", porque las excepciones no controladas por el método bloquearán el proceso.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Evite métodos async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Evite usar la lambda async para un tipo de delegado de devolución void, porque las excepciones no controladas por el delegado bloquearán el proceso.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Evite delegados asincrónicos no compatibles</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Los delegados de AsyncEventHandler deben invocarse a través del método de extensión "TplExtensions.InvokeAsync()" definido en el ensamblado Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Use InvokeAsync para desencadenar eventos asincrónicos</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>La llamada a await en un elemento Task dentro de JoinableTaskFactory.Run, cuando la tarea se ha iniciado fuera del delegado, puede provocar potenciales interbloqueos.
Puede evitar este problema asegurándose de que la tarea se ha iniciado dentro del delegado o usando JoinableTask en lugar de Task.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Evite usar await para tareas que no sean de unión en contextos de unión</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value puede provocar interbloqueos.
Use AsyncLazy&lt;T&gt; en su lugar.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Uso de AsyncLazy&lt;T&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await {1} en su lugar.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} bloquea sincrónicamente. Use await en su lugar.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Llame a métodos asincrónicos cuando esté en un método asincrónico</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Limite el uso de llamadas de métodos de bloqueo sincrónico, como JoinableTaskFactory.Run o Task.Result, a miembros de punto de entrada públicos donde tiene que ser sincrónico. El uso para miembros internos puede agregar innecesariamente marcos sincrónicos entre marcos asincrónicos, provocando el agotamiento del conjunto de subprocesos.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Implemente la lógica interna asincrónicamente</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Cambie el nombre a {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Use el sufijo "Async" para métodos asincrónicos</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Cambie el tipo de valor devuelto a Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current. Use una sobrecarga que acepte un elemento TaskScheduler y especifique TaskScheduler.Default (o cualquier otro) explícitamente.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Evite las sobrecargas de métodos que asumen TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Proporcione una instancia de JoinableTaskFactory en esta llamada (u otra sobrecarga) para evitar interbloqueos con el subproceso principal.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Proporcione JoinableTaskFactory donde se permita</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Exponga una versión asincrónica de este método que no cause bloqueo de manera sincrónica. A continuación, simplifique este método para llamar a ese método asincrónico dentro de un delegado JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Ofrezca métodos asincrónicos</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Use el método await JoinableTaskFactory.SwitchToMainThreadAsync() para cambiar al subproceso de interfaz de usuario en lugar de a API que pueden causar interbloqueo o requerir que se especifique una prioridad.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Evite cambiar a API de subprocesos heredados</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Falta el operador await en la expresión "using".</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Usar await para tarea dentro de expresión using</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Usar await en expresión using</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Use await en su lugar</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>Las comprobaciones de afinidad de subproceso deben ser incondicionales.</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>Declarar afinidad de subproceso incondicionalmente</value>
  </data>
  <data name="VSTHRD109_MessageFormat" xml:space="preserve">
    <value>Evite lanzar cuando no esté en el subproceso principal durante un método asincrónico o que devuelve tareas. Cambie en su lugar al subproceso requerido.</value>
  </data>
  <data name="VSTHRD109_Title" xml:space="preserve">
    <value>Cambiar en lugar de declarar en métodos asincrónicos</value>
  </data>
  <data name="VSTHRD010_MessageFormat_Sync" xml:space="preserve">
    <value>El acceso a "{0}" solo se debe realizar en el subproceso principal. Llame primero a {1}().</value>
    <comment>{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_MessageFormat_Async" xml:space="preserve">
    <value>El acceso a "{0}" solo se debe realizar en el subproceso principal. Espere primero a JoinableTaskFactory.SwitchToMainThreadAsync().</value>
    <comment>{0} is a type or member name.</comment>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>Se deben esperar las llamadas a JoinableTaskFactory.SwitchToMainThreadAsync().</value>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>Esperar a SwitchToMainThreadAsync</value>
    <comment>Do not translate either of these. The first is a keyword, the second is a method name.</comment>
  </data>
  <data name="VSTHRD110_MessageFormat" xml:space="preserve">
    <value>Observe el resultado que se puede esperar de esta llamada a método cuando se espera, se asigna a una variable o se pasa a otro método.</value>
  </data>
  <data name="VSTHRD110_Title" xml:space="preserve">
    <value>Observar resultado de llamadas asincrónicas</value>
  </data>
  <data name="VSTHRD011b_MessageFormat" xml:space="preserve">
    <value>Invocar o bloquear en código asincrónico en un generador de valores Lazy&lt;T&gt; puede provocar interbloqueos.
Use en su lugar AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD200_AddAsync_MessageFormat" xml:space="preserve">
    <value>Use el sufijo "Async" en nombres de métodos que devuelven un tipo que admite await.</value>
  </data>
  <data name="VSTHRD200_RemoveAsync_MessageFormat" xml:space="preserve">
    <value>Evite el sufijo "Async" en nombres de métodos que no devuelven un tipo que admite await.</value>
  </data>
  <data name="VSTHRD111_CodeFix_False_Title" xml:space="preserve">
    <value>Agregar .ConfigureAwait(false)</value>
    <comment>".ConfigureAwait(false)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_CodeFix_True_Title" xml:space="preserve">
    <value>Agregar .ConfigureAwait(true)</value>
    <comment>".ConfigureAwait(true)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_MessageFormat" xml:space="preserve">
    <value>Agregue .ConfigureAwait(bool) a su expresión await.</value>
    <comment>".ConfigureAwait(bool)" and "await" should NOT be translated.</comment>
  </data>
  <data name="VSTHRD111_Title" xml:space="preserve">
    <value>Usar ConfigureAwait(bool)</value>
    <comment>"ConfigureAwait(bool)" is a reference and should NOT be translated.</comment>
  </data>
</root>