<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="ko" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="translated">대신 {0}을(를) 기다립니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="translated">대신 await를 사용합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use await or JoinableTaskFactory.Run instead.</source>
          <target state="translated">작업을 동기적으로 대기합니다. 그러지 않으면 대기자가 교착 상태를 일으킬 수 있습니다. 대신 await나 JoinableTaskFactory.Run을 사용합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
          <source>Avoid problematic synchronous waits</source>
          <target state="translated">문제가 있는 동기 대기를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
          <source>Invoke single-threaded types on Main thread</source>
          <target state="translated">주 스레드에서 단일 스레드 형식을 호출</target>
        </trans-unit>
        <trans-unit id="VSTHRD100_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
          <target state="translated">메서드에서 처리하지 않은 예외로 프로세스가 중단될 수 있으므로 "async void" 메서드를 사용하지 마세요.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD100_Title" translate="yes" xml:space="preserve">
          <source>Avoid async void methods</source>
          <target state="translated">async void 메서드를 사용하지 않습니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD101_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
          <target state="translated">대리자에서 처리하지 않은 예외로 프로세스가 중단될 수 있으므로 void 반환 대리자 형식에 대해 비동기 람다를 사용하지 마세요.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD101_Title" translate="yes" xml:space="preserve">
          <source>Avoid unsupported async delegates</source>
          <target state="translated">지원되지 않는 비동기 대리자를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD106_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="translated">Microsoft.VisualStudio.Threading 어셈블리에 정의된 "TplExtensions.InvokeAsync()" 확장 메서드를 통해 AsyncEventHandler 대리자를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD106_Title" translate="yes" xml:space="preserve">
          <source>Use InvokeAsync to raise async events</source>
          <target state="translated">비동기 이벤트를 발생하는 InvokeAsync 사용</target>
        </trans-unit>
        <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task when the task is initialized in another context can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the same method or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation">작업이 외부에서 초기화되면 대리자가 잠재적인 교착 상태를 일으킬 수 있으므로 JoinableTaskFactory.Run 내 Task에서 호출을 대기합니다.
작업이 대리자 내에서 초기화되도록 하거나 Task 대신 JoinableTask를 사용하여 이 문제를 방지할 수 있습니다.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
          <source>Avoid awaiting foreign Tasks</source>
          <target state="needs-review-translation">조인 컨텍스트에서 조인할 수 없는 작업을 대기하지 않습니다.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
          <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
          <target state="translated">Lazy&lt;Task&lt;T&gt;&gt;.Value가 교착 상태가 될 수 있습니다.
대신 AsyncLazy&lt;T&gt;를 사용하세요.</target>
        </trans-unit>
        <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
          <source>Use AsyncLazy<it id="1" pos="open">&lt;T&gt;</it></source>
          <target state="translated">AsyncLazy&lt;it id="1" pos="open"&gt;&lt;T&gt;&lt;/it&gt; 사용</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_MessageFormat" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Await {1} instead.</source>
          <target state="translated">{0}이(가) 동기적으로 차단합니다. 대신 {1}을(를) 기다립니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Use await instead.</source>
          <target state="translated">{0}이(가) 동기적으로 차단합니다. 대신 await를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_Title" translate="yes" xml:space="preserve">
          <source>Call async methods when in an async method</source>
          <target state="translated">비동기 메서드인 경우 비동기 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD102_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="translated">동기화되어야 하는 공개 진입점 멤버에 JoinableTaskFactory.Run 또는 Task.Resut처럼 동기적으로 차단하는 메서드 호출 사용을 제한합니다. 내부 멤버에 이러한 매서드 호출을 사용하면 비동기 프레임 사이에 동기 프레임을 불필요하게 추가하여 threadpool이 소모될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD102_Title" translate="yes" xml:space="preserve">
          <source>Implement internal logic asynchronously</source>
          <target state="translated">내부 논리를 비동기적으로 구현</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="translated">{0}(으)로 이름 바꾸기</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD200_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods</source>
          <target state="translated">비동기 메서드에 "Async" 접미사 사용</target>
        </trans-unit>
        <trans-unit id="VSTHRD100_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Change return type to Task</source>
          <target state="translated">반환 형식을 Task로 변경</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD105_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
          <target state="translated">TaskScheduler.Current를 가정하는 메서드 오버로드를 사용하지 않습니다. TaskScheduler를 수용하고 TaskScheduler.Default(또는 기타)를 명시적으로 지정하는 오버로드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD105_Title" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current</source>
          <target state="translated">TaskScheduler.Current를 가정하는 메서드 오버로드를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
          <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
          <target state="translated">주 스레드에서 교착 상태를 방지하려면 이 호출(또는 다른 오버로드)에서 JoinableTaskFactory의 인스턴스를 제공하세요.</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
          <source>Provide JoinableTaskFactory where allowed</source>
          <target state="translated">허용되는 경우 JoinableTaskFactory 제공</target>
        </trans-unit>
        <trans-unit id="VSTHRD104_MessageFormat" translate="yes" xml:space="preserve">
          <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
          <target state="translated">동기적으로 차단되지 않는 이 메서드의 비동기 버전을 노출하세요. 그런 다음 JoinableTaskFactory.Run 대리자 내의 해당 비동기 메서드를 호출하도록 이 메서드를 단순화하세요.</target>
        </trans-unit>
        <trans-unit id="VSTHRD104_Title" translate="yes" xml:space="preserve">
          <source>Offer async methods</source>
          <target state="translated">비동기 메서드 제공</target>
        </trans-unit>
        <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
          <target state="translated">JoinableTaskFactory.SwitchToMainThreadAsync()가 교착 상태를 일으킬 수 있고 우선 순위를 지정해야 하는 API 대신 UI 스레드로 전환될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
          <source>Avoid legacy thread switching APIs</source>
          <target state="translated">레거시 스레드 전환 API 방지</target>
          <note from="MultilingualBuild" annotates="source" priority="2">thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_MessageFormat" translate="yes" xml:space="preserve">
          <source>Missing await operator for "using" expression.</source>
          <target state="translated">"using" 식의 await 연산자 누락</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_Title" translate="yes" xml:space="preserve">
          <source>Await Task within using expression</source>
          <target state="translated">using 식의 await Task</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Await using expression</source>
          <target state="translated">await using 식</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_CodeFix_Await_Title" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="translated">대신 await를 사용합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD108_MessageFormat" translate="yes" xml:space="preserve">
          <source>Thread affinity checks should be unconditional.</source>
          <target state="translated">스레드 선호도 검사는 비조건부여야 합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD108_Title" translate="yes" xml:space="preserve">
          <source>Assert thread affinity unconditionally</source>
          <target state="translated">무조건 스레드 선호도 어설션</target>
        </trans-unit>
        <trans-unit id="VSTHRD109_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid throwing when not on the main thread while in an async or Task-returning method. Switch to the thread required instead.</source>
          <target state="translated">비동기 또는 태스크 반환 메서드에서 주 스레드에 있지 않은 경우 throw하지 않습니다. 대신 필수 스레드로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD109_Title" translate="yes" xml:space="preserve">
          <source>Switch instead of assert in async methods</source>
          <target state="translated">비동기 메서드에서 어설션 대신 전환</target>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat_Sync" translate="yes" xml:space="preserve">
          <source>Accessing "{0}" should only be done on the main thread. Call {1}() first.</source>
          <target state="translated">주 스레드에서만 "{0}"에 액세스해야 합니다. 우선 {1}()을(를) 호출합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat_Async" translate="yes" xml:space="preserve">
          <source>Accessing "{0}" should only be done on the main thread. Await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
          <target state="translated">주 스레드에서만 "{0}"에 액세스해야 합니다. 우선 JoinableTaskFactory.SwitchToMainThreadAsync()를 대기합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calls to JoinableTaskFactory.SwitchToMainThreadAsync() must be awaited.</source>
          <target state="translated">JoinableTaskFactory.SwitchToMainThreadAsync() 호출을 대기해야 합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
          <source>Await SwitchToMainThreadAsync</source>
          <target state="translated">Await SwitchToMainThreadAsync</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Do not translate either of these. The first is a keyword, the second is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD110_MessageFormat" translate="yes" xml:space="preserve">
          <source>Observe the awaitable result of this method call by awaiting it, assigning to a variable, or passing it to another method.</source>
          <target state="translated">이 메서드 호출을 대기하거나, 변수에 할당하거나, 다른 메서드에 전달함으로써 해당 호출의 대기할 수 있는 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD110_Title" translate="yes" xml:space="preserve">
          <source>Observe result of async calls</source>
          <target state="translated">비동기 호출의 결과 확인</target>
        </trans-unit>
        <trans-unit id="VSTHRD011b_MessageFormat" translate="yes" xml:space="preserve">
          <source>Invoking or blocking on async code in a Lazy<it id="1" pos="open">&lt;T&gt;</it> value factory can deadlock.
Use AsyncLazy<it id="2" pos="open">&lt;T&gt;</it> instead.</source>
          <target state="translated">Lazy&lt;it id="1" pos="open"&gt;&lt;T&gt;&lt;/it&gt; 값 팩터리의 비동기 코드를 호출하거나 차단하면 교착 상태가 될 수 있습니다.
대신 AsyncLazy&lt;it id="2" pos="open"&gt;&lt;T&gt;&lt;/it&gt;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_AddAsync_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of methods that return an awaitable type.</source>
          <target state="translated">대기할 수 있는 형식을 반환하는 메서드의 이름에 "Async" 접미사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_RemoveAsync_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "Async" suffix in names of methods that do not return an awaitable type.</source>
          <target state="translated">대기할 수 있는 형식을 반환하지 않는 메서드의 이름에 "Async" 접미사를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="VSTHRD111_CodeFix_False_Title" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(false)</source>
          <target state="translated">.ConfigureAwait(false)를 추가합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(false)" should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_CodeFix_True_Title" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(true)</source>
          <target state="translated">.ConfigureAwait(true)를 추가합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(true)" should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_MessageFormat" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(bool) to your await expression.</source>
          <target state="translated">.ConfigureAwait(bool)를 await 식에 추가합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(bool)" and "await" should NOT be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_Title" translate="yes" xml:space="preserve">
          <source>Use ConfigureAwait(bool)</source>
          <target state="translated">ConfigureAwait(bool)를 사용합니다.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"ConfigureAwait(bool)" is a reference and should NOT be translated.</note>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>