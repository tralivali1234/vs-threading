<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="fr" original="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1795.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.VISUALSTUDIO.THREADING.ANALYZERS/STRINGS.RESX" datatype="resx">
        <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
          <source>Await {0} instead</source>
          <target state="translated">Attendre {0} à la place</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="translated">Utiliser await à la place</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
          <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use await or JoinableTaskFactory.Run instead.</source>
          <target state="translated">L'attente de manière synchrone de tâches ou d’éléments en attente peut entraîner des blocages. Utilisez await ou JoinableTaskFactory.Run à la place.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
          <source>Avoid problematic synchronous waits</source>
          <target state="translated">Éviter les attentes synchrones problématiques</target>
        </trans-unit>
        <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
          <source>Invoke single-threaded types on Main thread</source>
          <target state="translated">Appeler les types à thread unique sur le thread principal</target>
        </trans-unit>
        <trans-unit id="VSTHRD100_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
          <target state="translated">Évitez les méthodes "async void", car toute exception non traitée par la méthode bloque le processus.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD100_Title" translate="yes" xml:space="preserve">
          <source>Avoid async void methods</source>
          <target state="translated">Éviter les méthodes async void</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
        </trans-unit>
        <trans-unit id="VSTHRD101_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
          <target state="translated">Évitez d’utiliser une expression lambda asynchrone pour un type de délégué retournant void, car toute exception non traitée par la méthode bloque le processus.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD101_Title" translate="yes" xml:space="preserve">
          <source>Avoid unsupported async delegates</source>
          <target state="translated">Éviter les délégués async non pris en charge</target>
        </trans-unit>
        <trans-unit id="VSTHRD106_MessageFormat" translate="yes" xml:space="preserve">
          <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
          <target state="translated">Les délégués AsyncEventHandler doivent être appelés avec la méthode d’extension "TplExtensions.InvokeAsync()" définie dans l’assembly Microsoft.VisualStudio.Threading.</target>
        </trans-unit>
        <trans-unit id="VSTHRD106_Title" translate="yes" xml:space="preserve">
          <source>Use InvokeAsync to raise async events</source>
          <target state="translated">Utiliser InvokeAsync pour déclencher des événements async</target>
        </trans-unit>
        <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calling await on a Task when the task is initialized in another context can cause potential deadlocks.
You can avoid this problem by ensuring the task is initialized within the same method or by using JoinableTask instead of Task.</source>
          <target state="needs-review-translation">Le fait d’appeler await sur une tâche dans une méthode JoinableTaskFactory.Run quand la tâche est initialisée en dehors du délégué peut entraîner des blocages.
Vous pouvez éviter ce problème en vérifiant que la tâche est initialisée dans le délégué ou en utilisant JoinableTask à la place de Task.</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
          <source>Avoid awaiting foreign Tasks</source>
          <target state="needs-review-translation">Éviter d’attendre des tâches non joignables dans des contextes de jointure</target>
          <note from="MultilingualUpdate" annotates="source" priority="2">Please verify the translation’s accuracy as the source string was updated after it was translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
          <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
          <target state="translated">Lazy&lt;Task&lt;T&gt;&gt;.Value peut entraîner un blocage.
Utilisez AsyncLazy&lt;T&gt; à la place</target>
        </trans-unit>
        <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
          <source>Use AsyncLazy<it id="1" pos="open">&lt;T&gt;</it></source>
          <target state="translated">Utiliser AsyncLazy&lt;it id="1" pos="open"&gt;&lt;T&gt;&lt;/it&gt;</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_MessageFormat" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Await {1} instead.</source>
          <target state="translated">{0} bloque de façon synchrone. Attendez {1} à la place.</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
          <source>{0} synchronously blocks. Use await instead.</source>
          <target state="translated">{0} bloque de façon synchrone. Utilisez await à la place</target>
        </trans-unit>
        <trans-unit id="VSTHRD103_Title" translate="yes" xml:space="preserve">
          <source>Call async methods when in an async method</source>
          <target state="translated">Appeler des méthodes async dans une méthode async</target>
        </trans-unit>
        <trans-unit id="VSTHRD102_MessageFormat" translate="yes" xml:space="preserve">
          <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
          <target state="translated">Limitez l'utilisation des appels de méthode de blocage synchrones, comme JoinableTaskFactory.Run ou Task.Result, aux membres de point d’entrée publics où il est nécessaire d’être synchrone. Son utilisation pour des membres internes peut inutilement ajouter des frames synchrones entre les frames asynchrones, provoquant l'épuisement du pool de threads.</target>
        </trans-unit>
        <trans-unit id="VSTHRD102_Title" translate="yes" xml:space="preserve">
          <source>Implement internal logic asynchronously</source>
          <target state="translated">Implémenter la logique interne de façon asynchrone</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Rename to {0}</source>
          <target state="translated">Renommer en {0}</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD200_Title" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix for async methods</source>
          <target state="translated">Utiliser le suffixe "Async" pour les méthodes asynchrones</target>
        </trans-unit>
        <trans-unit id="VSTHRD100_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Change return type to Task</source>
          <target state="translated">Remplacer le type de retour par Task</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD105_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
          <target state="translated">Évitez les surcharges de méthode qui optent par défaut pour TaskScheduler.Current. Utilisez une surcharge qui accepte un TaskScheduler et spécifiez TaskScheduler.Default (ou autre chose) de manière explicite.</target>
        </trans-unit>
        <trans-unit id="VSTHRD105_Title" translate="yes" xml:space="preserve">
          <source>Avoid method overloads that assume TaskScheduler.Current</source>
          <target state="translated">Éviter les surcharges de méthode qui optent par défaut pour TaskScheduler.Current</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
          <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
          <target state="translated">Fournissez une instance de JoinableTaskFactory dans cet appel (ou une autre surcharge) pour éviter les blocages avec le même thread.</target>
        </trans-unit>
        <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
          <source>Provide JoinableTaskFactory where allowed</source>
          <target state="translated">Fournir JoinableTaskFactory quand autorisé</target>
        </trans-unit>
        <trans-unit id="VSTHRD104_MessageFormat" translate="yes" xml:space="preserve">
          <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
          <target state="translated">Exposez une version asynchrone de cette méthode qui ne se bloque pas de manière synchrone. Ensuite, simplifiez cette méthode pour appeler cette méthode async dans un délégué JoinableTaskFactory.Run.</target>
        </trans-unit>
        <trans-unit id="VSTHRD104_Title" translate="yes" xml:space="preserve">
          <source>Offer async methods</source>
          <target state="translated">Offrir des méthodes async</target>
        </trans-unit>
        <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
          <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
          <target state="translated">Attendez que JoinableTaskFactory.SwitchToMainThreadAsync() passe au thread d'interface utilisateur au lieu des API susceptibles de se bloquer ou de demander une priorité.</target>
        </trans-unit>
        <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
          <source>Avoid legacy thread switching APIs</source>
          <target state="translated">Éviter les API de commutation de thread héritées</target>
          <note from="MultilingualBuild" annotates="source" priority="2">thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_MessageFormat" translate="yes" xml:space="preserve">
          <source>Missing await operator for "using" expression.</source>
          <target state="translated">Opérateur await manquant pour l’expression "using".</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_Title" translate="yes" xml:space="preserve">
          <source>Await Task within using expression</source>
          <target state="translated">Tâche Await dans l’expression using</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD107_CodeFix_Title" translate="yes" xml:space="preserve">
          <source>Await using expression</source>
          <target state="translated">Attendre l’expression using</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD002_CodeFix_Await_Title" translate="yes" xml:space="preserve">
          <source>Use await instead</source>
          <target state="translated">Utiliser await à la place</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD108_MessageFormat" translate="yes" xml:space="preserve">
          <source>Thread affinity checks should be unconditional.</source>
          <target state="translated">Les vérifications d'affinité de thread doivent être inconditionnelles.</target>
        </trans-unit>
        <trans-unit id="VSTHRD108_Title" translate="yes" xml:space="preserve">
          <source>Assert thread affinity unconditionally</source>
          <target state="translated">Effectuer l'assertion de l'affinité de thread de manière inconditionnelle</target>
        </trans-unit>
        <trans-unit id="VSTHRD109_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid throwing when not on the main thread while in an async or Task-returning method. Switch to the thread required instead.</source>
          <target state="translated">Évitez toute levée quand vous n'êtes pas sur the thread principal dans une méthode retournant async ou Task. Basculez plutôt sur le thread requis.</target>
        </trans-unit>
        <trans-unit id="VSTHRD109_Title" translate="yes" xml:space="preserve">
          <source>Switch instead of assert in async methods</source>
          <target state="translated">Basculer sur des méthodes async plutôt qu'assert</target>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat_Sync" translate="yes" xml:space="preserve">
          <source>Accessing "{0}" should only be done on the main thread. Call {1}() first.</source>
          <target state="translated">L'accès à "{0}" doit être uniquement effectué sur le thread principal. Appelez d'abord {1}().</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</note>
        </trans-unit>
        <trans-unit id="VSTHRD010_MessageFormat_Async" translate="yes" xml:space="preserve">
          <source>Accessing "{0}" should only be done on the main thread. Await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
          <target state="translated">L'accès à "{0}" doit être uniquement effectué sur le thread principal. Attendez d'abord JoinableTaskFactory.SwitchToMainThreadAsync().</target>
          <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
          <source>Calls to JoinableTaskFactory.SwitchToMainThreadAsync() must be awaited.</source>
          <target state="translated">Vous devez attendre les appels à JoinableTaskFactory.SwitchToMainThreadAsync().</target>
        </trans-unit>
        <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
          <source>Await SwitchToMainThreadAsync</source>
          <target state="translated">Attendre SwitchToMainThreadAsync</target>
          <note from="MultilingualBuild" annotates="source" priority="2">Do not translate either of these. The first is a keyword, the second is a method name.</note>
        </trans-unit>
        <trans-unit id="VSTHRD110_MessageFormat" translate="yes" xml:space="preserve">
          <source>Observe the awaitable result of this method call by awaiting it, assigning to a variable, or passing it to another method.</source>
          <target state="translated">Observez le résultat pouvant être attendu de cet appel de méthode en l'attendant, en l'assignant à une variable ou en le passant à une autre méthode.</target>
        </trans-unit>
        <trans-unit id="VSTHRD110_Title" translate="yes" xml:space="preserve">
          <source>Observe result of async calls</source>
          <target state="translated">Observer le résultat des appels async</target>
        </trans-unit>
        <trans-unit id="VSTHRD011b_MessageFormat" translate="yes" xml:space="preserve">
          <source>Invoking or blocking on async code in a Lazy<it id="1" pos="open">&lt;T&gt;</it> value factory can deadlock.
Use AsyncLazy<it id="2" pos="open">&lt;T&gt;</it> instead.</source>
          <target state="translated">Les appels ou blocages sur le code async dans une fabrique de valeurs Lazy&lt;it id="1" pos="open"&gt;&lt;T&gt;&lt;/it&gt; peuvent faire l'objet d'un interblocage.
Utilisez plutôt AsyncLazy&lt;it id="2" pos="open"&gt;&lt;T&gt;&lt;/it&gt;.</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_AddAsync_MessageFormat" translate="yes" xml:space="preserve">
          <source>Use "Async" suffix in names of methods that return an awaitable type.</source>
          <target state="translated">Utilisez le suffixe "Async" dans les noms des méthodes qui retournent un type awaitable.</target>
        </trans-unit>
        <trans-unit id="VSTHRD200_RemoveAsync_MessageFormat" translate="yes" xml:space="preserve">
          <source>Avoid "Async" suffix in names of methods that do not return an awaitable type.</source>
          <target state="translated">Évitez le suffixe "Async" dans les noms des méthodes qui ne retournent pas un type awaitable</target>
        </trans-unit>
        <trans-unit id="VSTHRD111_CodeFix_False_Title" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(false)</source>
          <target state="translated">Ajouter .ConfigureAwait(false)</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(false)" should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_CodeFix_True_Title" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(true)</source>
          <target state="translated">Ajouter .ConfigureAwait(true)</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(true)" should not be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_MessageFormat" translate="yes" xml:space="preserve">
          <source>Add .ConfigureAwait(bool) to your await expression.</source>
          <target state="translated">Ajoutez .ConfigureAwait(bool) à votre expression await.</target>
          <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(bool)" and "await" should NOT be translated.</note>
        </trans-unit>
        <trans-unit id="VSTHRD111_Title" translate="yes" xml:space="preserve">
          <source>Use ConfigureAwait(bool)</source>
          <target state="translated">Utiliser ConfigureAwait(bool)</target>
          <note from="MultilingualBuild" annotates="source" priority="2">"ConfigureAwait(bool)" is a reference and should NOT be translated.</note>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>